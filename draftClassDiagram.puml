@startuml

skinparam linetype ortho

package "Presentation" #LightBlue {
    class LinterDisplay {
        + main(args: String[]): void
        + run(): void
    }
    
    class ConsoleReporter {
        + report(issues: List<LintIssue>): void
    }
}

package "Domain" #LightGreen {
    
    class LinterEngine {
        - checks: List<LintCheck>
        + addCheck(check: LintCheck): void
        + removeCheck(check: LintCheck): void
        + analyze(classInfo: ClassInfo): List<LintIssue>
    }
    
    enum CheckCategory {
        STYLE
        PRINCIPLE
        PATTERN
    }
    
    class ResultManager {
        + addResult(className: String, issues: List<LintIssue>): void
        + getSummary(): LintSummary
    }
    
    class LintSummary {
        - errorCount: int
        - warningCount: int
    }
    
    class LintIssue {
        - checkName: String
        - severity: Severity
        - message: String
        + LintIssue(checkName, severity, message, location)
    }
    
    enum Severity {
        ERROR
        WARNING
        INFO
    }
    
    class ClassInfo {
        - classNode: ClassNode
        - fields: List<FieldInfo>
        - methods: List<MethodInfo>
        + getName(): String
        + getInterfaces(): List<String>
        + isAbstract(): boolean
        + isInterface(): boolean
        + isPublic(): boolean
        + getFields(): List<FieldInfo>
        + getMethods(): List<MethodInfo>
    }
    
    class FieldInfo {

        - fieldNode: FieldNode
        + isStatic(): boolean
        + isFinal(): boolean
    }
    
    class MethodInfo {
        - methodNode: MethodNode
        + getInstructionCount(): int
        + getMethodCalls(): List<MethodCall>
    }
    
    class MethodCall {
        - owner: String
        - name: String
    }
    
    interface LintCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        + getName(): String
        + getDescription(): String
    }
    
    interface StyleCheck extends LintCheck
    interface PrincipleCheck extends LintCheck
    interface PatternCheck extends LintCheck{
        +checkWithContext(classInfo: ClassInfo, allClasses: Map<String, ClassInfo>): List<LintIssue>
    }
    
    ' Style Checks
    class ConfigurableMethodLengthCheck implements StyleCheck {
        - config: LinterConfig
        + ConfigurableMethodLengthCheck(config: LinterConfig)
        + ConfigurableMethodLengthCheck(warningThreshold: int, errorThreshold: int)
        + check(classInfo: ClassInfo): List<LintIssue>
        + getWarningThreshold(): int
        + getErrorThreshold(): int
        + getConfig(): LinterConfig
    }

    class LinterConfig {
        - methodLengthWarningThreshold: int
        - methodLengthErrorThreshold: int
        - configSource: String
        + LinterConfig()
        + LinterConfig(warningThreshold: int, errorThreshold: int)
        + loadFromFile(): void
        + setMethodLengthWarningThreshold(threshold: int): void
        + setMethodLengthErrorThreshold(threshold: int): void
        + setMethodLengthThresholds(warning: int, error: int): void
        + resetToDefaults(): void
        + getMethodLengthWarningThreshold(): int
        + getMethodLengthErrorThreshold(): int
        + getConfigSource(): String
    }
    
    class FieldNamingCheck implements StyleCheck {
        - UPPER_SNAKE_CASE: Pattern
        - CAMEL_CASE: Pattern
        + check(classInfo: ClassInfo): List<LintIssue>
    }

    class ImproperPrintCheck implements StyleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        +getName(): String
        +getDescription(): String
        -findLineNumber(insn: AbstractInsnNode):int
        -sourcePrefix(classInfo: ClassInfo, line: int): String
        -findFollowingPrintCalls(start: AbstractInsnNode, maxLookahead: int): MethodInsnNode

        }
    
    class UnusedVariableCheck implements StyleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - checkUnusedLocalVariables(classInfo: ClassInfo, issues: List<LintIssue>): void
        - checkUnusedPrivateFields(classInfo: ClassInfo, issues: List<LintIssue>): void
        - isMethodParameter(methodNode: MethodNode, index: int, isStatic: boolean): boolean
        - isLoadOpcode(opcode: int): boolean
    }

    class MethodNamingCheck implements StyleCheck {
        - CAMEL_CASE: Pattern
        + check(classInfo: ClassInfo): List<LintIssue>
        - getSuggestion(name: String): String
    }
    
    ' Principle Checks
    class ProgramToInterfaceCheck implements PrincipleCheck {
        - concreteTypes: Map<String, String>
        + isConcreteCollection(typeName: String): boolean
        + check(classInfo: ClassInfo): List<LintIssue>
    }
    
    class SingleResponsibilityCheck implements PrincipleCheck {
        - maxFields: int
        - maxMethods: int
        - lcom4Threshold: int
        - lcom4Enabled: boolean
        + check(classInfo: ClassInfo): List<LintIssue>
    }

    class "SingleResponsibilityCheck.UnionFind" as UnionFind {
        - parent: int[]
        - rank: int[]
        - components: int
        + find(x: int): int
        + union(a: int, b: int): void
        + getComponents(): int
    }

    SingleResponsibilityCheck --> UnionFind
    
    class LeastKnowledgeCheck implements PrincipleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - checkMethodForChaining(classInfo: ClassInfo, methodInfo: MethodInfo, issues: List<LintIssue>): void
        - isTrainWreck(firstCall: MethodInsnNode, secondCall: MethodInsnNode): boolean
        - isFluentSafeType(typeName: String): boolean
    }
    
    class OpenClosedPrincipleCheck implements PrincipleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        +getName(): String
        +getDescription(): String
        +checkWithContext(classInfo: ClassInfo, allClasses: Map<String, ClassInfo>): List<LintIssue>
        - addIfHeavyIssues(classInfo: ClassInfo, issues: List<LintIssue>): void
        - countConditionalsInMethod(methodInfo: MethodInfo): int
        - isIfOpcode(op: int): boolean
        - findImplementingClasses(iface: ClassInfo, allClasses: Map<String, ClassInfo>): List<String>
    }

    class SecurityPrincipleCheck implements PrincipleCheck {
        HIGH_ENTROPY_LIKE: Pattern
        AWS_ACCESS_KEY: Pattern
        JWT_LIKE: Pattern

        + check(classInfo: ClassInfo): List<LintIssue>
        +getName(): String
        +getDescription(): String
        -detectHardcodedSecrets(classInfo: ClassInfo, methodInfo: MethodInfo, at: AbstractInsnNode, s: String): void

    }
    
    ' Pattern Detectors
    class AdapterPatternDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - implmentsInterface(classInfo: ClassInfo): boolean
        - hasAdapteeField(classInfo: ClassInfo): boolean
        - delegatesToAdaptee(classInfo: ClassInfo): boolean
    }
    
    class TemplateMethodDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - findCalledAbstractMethods(method, abstractMethods, owner): Set<String>
    }
    
    class DecoratorPatternDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - detectDecorator(classInfo: ClassInfo, allClasses: Map): List<LintIssue>
        - countDelegationsTo(classInfo: ClassInfo, fieldType: String): int
        - getSimpleName(fullName: String): String
    }
    class StrategyPatternDetector implements PatternCheck{
        +getName(): String
        +getDescription(): String
        +check(classInfo: ClassInfo): List<LintIssue>
        +checkWithContext(classInfo: ClassInfo, allClasses: Map<String, ClassInfo>):
        -basicStrategyCheck(classInfo: ClassInfo): List<LintIssue>
        -advancedStrategyCheck(classInfo: ClassInfo, allClasses: Map<String, ClassInfo>): List<LintIssue>
        -resolveClassStrict(className: String, allClasses: Map<String, ClassInfo>): ClassInfo
        -stripDescriptor(descriptor: String): String
        -toInternalName(name: String): String
        -toDotName(name: String): String

    }
}

package "Data Source" #LightCoral {
    class ClassFileReader {
        + loadClass(className: String): ClassInfo
        + loadClassFromFile(filePath: String): ClassInfo
        + loadClasses(classNames: List<String>): List<ClassInfo>
    }
}

package "ASM Library" #DDDDDD {
    class ClassNode
    class FieldNode
    class MethodNode
    class ClassReader
}

LinterDisplay --> LinterEngine
LinterDisplay --> ConsoleReporter
LinterDisplay --> LinterConfig
ConsoleReporter ..> LintIssue

ConfigurableMethodLengthCheck --> LinterConfig

LinterEngine --> ClassFileReader
LinterEngine --> ResultManager
LinterEngine ..> "*" LintCheck

LintCheck ..> ClassInfo
LintCheck ..> LintIssue

ResultManager --> "*" LintIssue
ResultManager --> LintSummary

ClassInfo ..> "*" FieldInfo
ClassInfo ..> "*" MethodInfo
MethodInfo ..> "*" MethodCall
LintIssue ..> Severity
LinterEngine ..> CheckCategory

ClassFileReader --> ClassInfo
ClassFileReader --> ClassReader
ClassInfo --> ClassNode
FieldInfo --> FieldNode
MethodInfo --> MethodNode


@enduml