@startuml

skinparam linetype ortho

package "Presentation" #LightBlue {
    class LinterDisplay {
        + main(args: String[]): void
        + run(): void
    }
    
    class ConsoleReporter {
        + report(issues: List<LintIssue>): void
    }
}

package "Domain" #LightGreen {
    
    class LinterEngine {
        - checks: List<LintCheck>
        + addCheck(check: LintCheck): void
        + removeCheck(check: LintCheck): void
        + analyze(classInfo: ClassInfo): List<LintIssue>
    }
    
    enum CheckCategory {
        STYLE
        PRINCIPLE
        PATTERN
    }
    
    class ResultManager {
        + addResult(className: String, issues: List<LintIssue>): void
        + getSummary(): LintSummary
    }
    
    class LintSummary {
        - errorCount: int
        - warningCount: int
    }
    
    class LintIssue {
        - checkName: String
        - severity: Severity
        - message: String
        + LintIssue(checkName, severity, message, location)
    }
    
    enum Severity {
        ERROR
        WARNING
        INFO
    }
    
    class ClassInfo {
        - classNode: ClassNode
        - fields: List<FieldInfo>
        - methods: List<MethodInfo>
        + getName(): String
        + getInterfaces(): List<String>
        + isAbstract(): boolean
        + isInterface(): boolean
        + isPublic(): boolean
        + getFields(): List<FieldInfo>
        + getMethods(): List<MethodInfo>
    }
    
    class FieldInfo {

        - fieldNode: FieldNode
        + isStatic(): boolean
        + isFinal(): boolean
    }
    
    class MethodInfo {
        - methodNode: MethodNode
        + getInstructionCount(): int
        + getMethodCalls(): List<MethodCall>
    }
    
    class MethodCall {
        - owner: String
        - name: String
    }
    
    interface LintCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
    }
    
    interface StyleCheck extends LintCheck
    interface PrincipleCheck extends LintCheck
    interface PatternCheck extends LintCheck
    
    ' Style Checks
    class ConfigurableMethodLengthCheck implements StyleCheck {
        - maxInstructions: int
        + ConfigurableMethodLengthCheck(maxInstructions: int)
        + check(classInfo: ClassInfo): List<LintIssue>
        + setMaxInstructions(max: int): void
    }
    
    class FieldNamingCheck implements StyleCheck {
        - UPPER_SNAKE_CASE: Pattern
        - CAMEL_CASE: Pattern
        + check(classInfo: ClassInfo): List<LintIssue>
    }
    
    class UnusedVariableCheck implements StyleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - checkUnusedLocalVariables(classInfo: ClassInfo, issues: List<LintIssue>): void
        - checkUnusedPrivateFields(classInfo: ClassInfo, issues: List<LintIssue>): void
        - isMethodParameter(methodNode: MethodNode, index: int, isStatic: boolean): boolean
        - isLoadOpcode(opcode: int): boolean
    }

    class MethodNamingCheck implements StyleCheck {
        - CAMEL_CASE: Pattern
        + check(classInfo: ClassInfo): List<LintIssue>
        - getSuggestion(name: String): String
    }
    
    ' Principle Checks
    class ProgramToInterfaceCheck implements PrincipleCheck {
        - concreteTypes: Map<String, String>
        + isConcreteCollection(typeName: String): boolean
        + check(classInfo: ClassInfo): List<LintIssue>
    }
    
    class SingleResponsibilityCheck implements PrincipleCheck {
        - MAX_FIELDS: int 
        - MAX_METHODS: int
        - maxPublicMethods: int
        + check(classInfo: ClassInfo): List<LintIssue>
    }
    
    class LeastKnowledgeCheck implements PrincipleCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - checkMethodForChaining(classInfo: ClassInfo, methodInfo: MethodInfo, issues: List<LintIssue>): void
        - isTrainWreck(firstCall: MethodInsnNode, secondCall: MethodInsnNode): boolean
        - isFluentSafeType(typeName: String): boolean
    }
    class Principle4 implements PrincipleCheck
    
    ' Pattern Detectors
    class AdapterPatternDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - implmentsInterface(classInfo: ClassInfo): boolean
        - hasAdapteeField(classInfo: ClassInfo): boolean
        - delegatesToAdaptee(classInfo: ClassInfo): boolean
    }
    
    class TemplateMethodDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - findAbstractMethods(classInfo: ClassInfo): Set<String>
        - findTemplateMethods(classInfo: ClassInfo): List<String>
    }
    
    class DecoratorPatternDetector implements PatternCheck {
        + check(classInfo: ClassInfo): List<LintIssue>
        - detectDecorator(classInfo: ClassInfo, allClasses: Map): List<LintIssue>
        - countDelegationsTo(classInfo: ClassInfo, fieldType: String): int
        - getSimpleName(fullName: String): String
    }
    class Pattern4 implements PatternCheck
}

package "Data Source" #LightCoral {
    class ClassFileReader {
        + loadClass(className: String): ClassInfo
        + loadClassFromFile(filePath: String): ClassInfo
        + loadClasses(classNames: List<String>): List<ClassInfo>
    }
}

package "ASM Library" #DDDDDD {
    class ClassNode
    class FieldNode
    class MethodNode
    class ClassReader
}

LinterDisplay --> LinterEngine
LinterDisplay --> ConsoleReporter
ConsoleReporter ..> LintIssue

LinterEngine --> ClassFileReader
LinterEngine --> ResultManager
LinterEngine ..> "*" LintCheck

LintCheck ..> ClassInfo
LintCheck ..> LintIssue

ResultManager --> "*" LintIssue
ResultManager --> LintSummary

ClassInfo ..> "*" FieldInfo
ClassInfo ..> "*" MethodInfo
MethodInfo ..> "*" MethodCall
LintIssue ..> Severity
LinterEngine ..> CheckCategory

ClassFileReader --> ClassInfo
ClassFileReader --> ClassReader
ClassInfo --> ClassNode
FieldInfo --> FieldNode
MethodInfo --> MethodNode


@enduml